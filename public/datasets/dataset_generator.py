import random
import csv

# --------------------------------------------
# НАСТРОЙКИ
# --------------------------------------------

# Текущий год (на момент генерации датасета).
CURRENT_YEAR = 2024

# Курс -> Год набора
# Если курс = 1, значит год набора = CURRENT_YEAR (24)
# Если курс = 2, значит год набора = CURRENT_YEAR - 1 (23)
# и т.д.
COURSE_YEAR_MAP = {
    1: CURRENT_YEAR - 0,  # 24
    2: CURRENT_YEAR - 1,  # 23
    3: CURRENT_YEAR - 2,  # 22
    4: CURRENT_YEAR - 3   # 21
}

# Соответствие курса и семестров
# 1 курс -> 1-2 семестр
# 2 курс -> 3-4 семестр
# 3 курс -> 5-6 семестр
# 4 курс -> 7-8 семестр
COURSE_TO_SEMESTERS = {
    1: [1, 2],
    2: [3, 4],
    3: [5, 6],
    4: [7, 8]
}

# Предметы и семестры, в которых они читаются
# (можно корректировать под свои нужды)
subject_semester_map = {
    "Основы Big Data":      [1, 2],
    "Философия":            [1, 2, 7, 8],
    "Базы данных":          [3, 4],
    "Нейросетевые технологии": [3, 4],
    "Основы мобильной разработки": [3, 4],
    "Анализ бизнес-процессов":    [3, 4],
    "ООП":                  [3, 4, 5, 6],
    "Web-программирование": [5, 6],
    "Компьютерная графика": [7, 8],
    "Программирование на языке высокого уровня": [1, 2],
    "Моделирование процессов и систем": [5],
    "Иностранный язык": [1, 2, 3, 4, 5],
    "Управление проектами": [5],
    "Основы информационной безопасности": [5],
    "Безопасность жизнедеятельности": [7, 8],
    "Мониторинг безопасности информационных систем": [7],
    "Надежность информационных систем": [7],
    "Математика": [1, 2],
    "Физика": [1, 2],
    "Архитектура ЭВМ и систем": [2]
}

# Список направлений (наименование для группы)
DIRECTIONS = ["ИСТб", "ЭВМб", "АСУб", "ИБб"]

# Сколько групп на каждое направление (для простоты)
GROUPS_PER_DIRECTION = 2  # можно изменить

# Сколько студентов в каждой группе
STUDENTS_PER_GROUP_MIN = 6
STUDENTS_PER_GROUP_MAX = 15

# ФИО – для генерации
FIRST_NAMES = [
    'Александр', 'Иван', 'Дмитрий', 'Михаил', 'Артем',
    'Кирилл', 'Евгений', 'Владимир', 'Алексей', 'Игорь'
]
LAST_NAMES = [
    'Иванов', 'Петров', 'Смирнов', 'Кузнецов', 'Попов',
    'Васильев', 'Соколов', 'Михайлов', 'Новиков', 'Федоров'
]
PATRONYMICS = [
    'Александрович', 'Иванович', 'Дмитриевич',
    'Михайлович', 'Сергеевич', 'Андреевич'
]


# --------------------------------------------
# ГЕНЕРАЦИЯ ГРУПП И СТУДЕНТОВ
# --------------------------------------------

all_students = []  # Здесь будем хранить словари с данными студентов

# Перебираем курсы 1..4
for course in range(1, 5):
    # Определим год набора
    year_suffix = str(COURSE_YEAR_MAP[course])[-2:]  # берем последние две цифры года
    # Генерируем группы для каждого направления
    for direction in DIRECTIONS:
        for group_num in range(1, GROUPS_PER_DIRECTION + 1):
            group_name = f"{direction}-{year_suffix}-{group_num}"

            # Генерируем случайное число студентов в группе
            num_students = random.randint(STUDENTS_PER_GROUP_MIN, STUDENTS_PER_GROUP_MAX)
            for _ in range(num_students):
                fn = random.choice(FIRST_NAMES)
                ln = random.choice(LAST_NAMES)
                pn = random.choice(PATRONYMICS)
                fio = f"{ln} {fn} {pn}"

                # Каждый студент находится в одном семестре, но в рамках своего курса
                possible_semesters = COURSE_TO_SEMESTERS[course]
                semester = random.choice(possible_semesters)

                # Активность (одно значение для всего семестра)
                activity = random.randint(0, 10)

                # Словарь со всей информацией о студенте
                student_dict = {
                    "ФИО": fio,
                    "Группа": group_name,
                    "Курс": course,
                    "Семестр": semester,
                    "Активность": activity
                }
                all_students.append(student_dict)

# --------------------------------------------
# ГЕНЕРАЦИЯ ОЦЕНОК ПО ПРЕДМЕТАМ
# --------------------------------------------
# Для каждого студента создадим записи по предметам, которые читаются в его семестре.
# При этом для каждой такой пары (студент-предмет) сгенерируем от 1 до 3 оценок.
# --------------------------------------------

marks_rows = []
record_id = 1  # счетчик ID для строк CSV

for student in all_students:
    semester = student["Семестр"]
    fio = student["ФИО"]
    group_name = student["Группа"]
    course = student["Курс"]
    activity = student["Активность"]

    # Выберем предметы, которые соответствуют данному семестру
    valid_subjects = [
        subj for subj, sem_list in subject_semester_map.items()
        if semester in sem_list
    ]

    # Для каждого предмета генерируем оценки
    for subject in valid_subjects:
        # Сгенерируем от 1 до 3 оценок
        num_marks = random.randint(1, 3)
        for _ in range(num_marks):
            mark = random.randint(2, 5)          # Оценка от 2 до 5
            attendance = random.randint(0, 30)   # Посещаемость (0..30)

            row = {
                "id": record_id,
                "ФИО": fio,
                "Группа": group_name,
                "Курс": course,
                "Семестр": semester,
                "Предмет": subject,
                "Оценка": mark,
                "Активность": activity,
                "Посещаемость": attendance
            }
            marks_rows.append(row)
            record_id += 1

# --------------------------------------------
# СОХРАНЕНИЕ В CSV
# --------------------------------------------
with open("marks_dataset.csv", mode="w", encoding="utf-8", newline="") as f:
    fieldnames = [
        "id", "ФИО", "Группа", "Курс", "Семестр",
        "Предмет", "Оценка", "Активность", "Посещаемость"
    ]
    writer = csv.DictWriter(f, fieldnames=fieldnames, delimiter=';')
    writer.writeheader()
    writer.writerows(marks_rows)

print("Датасет успешно сгенерирован: marks_dataset.csv")
